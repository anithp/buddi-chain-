contract AccessNFT =
  record
    owner : address;
    next_token_id : int;
    tokens : map(int, token_data);
    token_owners : map(int, address);
    owner_tokens : map(address, list(int))
  end

  type token_data =
    { anchor_id : int;
      token_uri : string;
      created_at : int;
      creator : address }

  entrypoint init() : state =
    { owner = Call.caller;
      next_token_id = 1;
      tokens = {};
      token_owners = {};
      owner_tokens = {} }

  entrypoint mint(to : address, anchor_id : int, token_uri : string) : (int, state) =
    let token_id = state.next_token_id in
    let token_data = { anchor_id = anchor_id;
                      token_uri = token_uri;
                      created_at = Chain.timestamp;
                      creator = Call.caller } in
    let new_tokens = Map.put(token_id, token_data, state.tokens) in
    let new_token_owners = Map.put(token_id, to, state.token_owners) in
    let owner_token_list = switch(Map.lookup(to, state.owner_tokens))
      None => [token_id]
      Some(tokens) => token_id :: tokens in
    let new_owner_tokens = Map.put(to, owner_token_list, state.owner_tokens) in
    let new_state = { state | next_token_id = token_id + 1;
                              tokens = new_tokens;
                              token_owners = new_token_owners;
                              owner_tokens = new_owner_tokens } in
    (token_id, new_state)

  entrypoint transfer(to : address, token_id : int) : state =
    switch(Map.lookup(token_id, state.token_owners))
      None => abort("Token does not exist")
      Some(current_owner) =>
        if(current_owner != Call.caller)
          abort("Not the owner of this token")
        else
          let new_token_owners = Map.put(token_id, to, state.token_owners) in
          let current_owner_tokens = switch(Map.lookup(current_owner, state.owner_tokens))
            None => []
            Some(tokens) => List.filter(fn(token) => token != token_id, tokens) in
          let new_owner_tokens = Map.put(current_owner, current_owner_tokens, state.owner_tokens) in
          let to_tokens = switch(Map.lookup(to, new_owner_tokens))
            None => [token_id]
            Some(tokens) => token_id :: tokens in
          let final_owner_tokens = Map.put(to, to_tokens, new_owner_tokens) in
          { state | token_owners = new_token_owners;
                    owner_tokens = final_owner_tokens }

  entrypoint owner_of(token_id : int) : option(address) =
    Map.lookup(token_id, state.token_owners)

  entrypoint token_data(token_id : int) : option(token_data) =
    Map.lookup(token_id, state.tokens)

  entrypoint tokens_of(owner : address) : list(int) =
    switch(Map.lookup(owner, state.owner_tokens))
      None => []
      Some(tokens) => tokens

  entrypoint total_supply() : int =
    state.next_token_id - 1
